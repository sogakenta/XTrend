# アーキテクチャ根本レビュー

- **日付**: 2026-02-16
- **番号**: 004
- **ステータス**: 承認済み
- **関連**: 001, 002, 003

---

## 概要

シグナル機能やDB負荷対策を検討する中で、そもそもの設計前提を疑い、根本的なアーキテクチャレビューを実施した。

---

## レビュー結果

### 1. 「1時間に12回は読み過ぎ」は本当か？

**判定: 条件付きで反対**（常に過剰とは言えない）

- 一般的なWebアプリとして12回/時は異常ではない
- ただしデータ更新が1時間ごとなので鮮度メリットは薄い
- **本質問題は「頻度」より「同じ重いクエリを繰り返す設計」**
- `max_rows=1000`に当たる問題は性能以前に**正しさの問題**
- これは premature optimization ではなく、必須の修正

### 2. Supabaseは最適か？

**判定: MVPでは賛成**（今は移行しない）

| DB | 評価 |
|----|------|
| Supabase | Nano(共有CPU)で強くないが、Postgresでシグナル集計を素直に書ける。MVPに最適 |
| PlanetScale | 無料枠なし。現時点では不採用 |
| Neon | 有力なPostgres代替。将来の移行先候補 |
| D1/Turso | SQLite系で特性が違う。トレンド集計には不向き |
| Firestore/DynamoDB | アクセスパターン前提設計が強く要求される。過剰 |

**結論**: 今の課題はDB製品よりクエリ形状。まず設計是正がROI最大。

### 3. そもそもDB保存すべきか？

**判定: 条件付きで賛成**（DBは残す、配信用JSON併用）

- トップ/地域ページの「読むだけデータ」は**バッチ生成JSON + R2/S3/CDN配信**で軽くできる
- ただしterm履歴や分析軸追加、バックフィルを考えると**DBのソースオブトゥルースは必要**

**最適解: 「DB + 時間単位の配信用JSON」のハイブリッド**

```
[ingest] → [DB: trend_snapshot] (ソースオブトゥルース)
         → [JSON: /data/2026/02/16/12/jp.json] (配信用)
         → [CDN/R2] → [Web UI]
```

### 4. リアルタイム性は本当に必要か？

**判定: 反対**（リアルタイム要件は薄い）

- 1時間更新なら実質「バッチ更新データ配信」
- ISRでなく静的生成寄りでも成立する
- **「擬似リアルタイム設計」より「1時間バッチ前提設計」に寄せるべき**

### 5. On-Demand Revalidationは過剰か？

**判定: 条件付き**

| 方式 | 評価 |
|------|------|
| `revalidate=300` (現状) | データ更新頻度に対して過剰 |
| `revalidate=3600` | シンプルで十分。推奨 |
| On-Demand + fallback | 「ingest直後に確実更新」が必要なら価値あり |

**結論**: まず `revalidate=3600` に上げる。On-Demandは必要に応じて追加。

### 6. 競合を上回る必要はあるか？

**判定: 条件付きで賛成**

- MVP段階で"全部入り差別化"は不要
- ただし差別化ゼロだと比較されて終わる
- **最小差別化: `rankChange + NEW判定 + 横並び比較` だけ先に出す**
- 「1つ強い体験」に絞るべき

---

## やりすぎ/やらなさすぎの判断基準

| 基準 | 対応タイミング |
|------|---------------|
| 正しさが壊れる兆候 | `max_rows`到達やシグナル欠損が出たら**即対応** |
| コストが閾値超過 | Egress/DB使用量が無料枠70%継続超過なら次段階へ |
| 速度が体験を壊す | ページ生成P95が目標超えたら事前計算へ |
| 複雑性の純増 | 障害面積が大きく増えるなら見送る |
| 学習価値 | ユーザー検証前の重い移行は原則しない |
| 可逆性 | 戻せない移行より段階導入を優先 |

---

## 確定した優先順位

| 順序 | アクション | 理由 | 工数 |
|------|-----------|------|------|
| 1 | **Supabase継続** | 今の課題はDB製品ではない | - |
| 2 | **クエリ境界化**（時点固定・集計化） | 最優先、正しさの問題 | 0.5-1日 |
| 3 | `revalidate=3600` に変更 | 簡単で効果大 | 0.5時間 |
| 4 | 最小シグナル実装（rankChange + NEW） | 差別化の最小単位 | 1-2日 |
| 5 | On-Demand Revalidation（必要なら） | 複雑さとのトレードオフ | 1日 |
| 6 | ingest時シグナル事前計算 | 次段階 | 2-4日 |
| 7 | ホットページJSON配信 | その後 | 1-2日 |

---

## アーキテクチャ方針（確定）

### 現フェーズ（MVP）

```
[X API] → [Cloud Run: ingest] → [Supabase: PostgreSQL]
                                       ↓
[User] → [Vercel/Cloud Run: Next.js] ← ISR (revalidate=3600)
```

### 次フェーズ（スケール時）

```
[X API] → [Cloud Run: ingest] → [Supabase: PostgreSQL] (ソースオブトゥルース)
                              → [R2/S3: JSON] (配信用)
                              → [CDN Edge Cache]
                                       ↓
[User] → [Vercel/Cloud Run: Next.js] ← On-Demand Revalidation
```

---

## 見送り事項

| 事項 | 理由 |
|------|------|
| DB移行（Neon等） | 今の課題はDB製品ではない |
| マテリアライズドビュー | クエリ境界化で十分 |
| 完全SSG | 動的ページ運用を切る判断が必要 |
| 全シグナル実装 | まず最小差別化で検証 |

---

## 参考

- Next.js ISR: https://nextjs.org/docs/app/building-your-application/data-fetching/incremental-static-regeneration
- Supabase Limits: https://supabase.com/docs/guides/platform/compute-and-disk
- Neon: https://neon.com/docs/introduction/plans
- Cloudflare R2: https://developers.cloudflare.com/r2/pricing/
